# Описание работы B-дерева

B-дерево — это самобалансирующаяся структура данных, предназначенная для эффективного хранения, поиска, вставки и удаления больших объемов информации с минимальным количеством операций ввода-вывода.

---

## Ключевые особенности

- **Сбалансированность**: дерево поддерживает равномерную высоту всех ветвей.
- **Оптимизация ввода-вывода**: минимизация количества чтений с диска.
- **Параметризуемая степень `t`**: степень дерева определяет диапазон допустимого числа ключей и дочерних узлов в каждом узле.

---

## Основные характеристики

- **Узел**: хранит упорядоченные ключи и связанные с ними списки значений (ID).
- **Корень**: начальный узел дерева, на который не ссылаются другие узлы.
- **Лист**: узел, не имеющий дочерних узлов.

Структура каждого узла:
- Ключи упорядочены по возрастанию.
- Количество дочерних узлов = Количество ключей + 1.
- Указатели на детей размещаются между ключами.
---

## Ограничения на количество ключей и детей

Для дерева степени `t`:

- Минимальное количество ключей в узле: `t - 1`
- Максимальное количество ключей в узле: `2t - 1`
- Минимальное количество детей: `t`
- Максимальное количество детей: `2t`

Высота дерева `h` оценивается как:

 h <= log_t((n + 1) / 2)

```math 
h \leq \log_t \left( \frac{n + 1}{2} \right)
```
>где `n` — количество элементов.

> Чем выше `t`, тем меньше высота дерева и тем меньше операций ввода-вывода.

---

## Операции (во всех примерах t = 3)


### Поиск ключа

Поиск ключа в B-дереве начинается с корня и на каждом уровне:
- Последовательно перебираются ключи в узле.
- Определяется, следует ли продолжать поиск в потомке.
- Если найден нужный ключ, операция завершается успешно.

При достижении листа без нахождения ключа поиск считается неудачным.



### Вставка нового ключа

Добавление происходит в несколько этапов:
- Искомый ключ вставляется в соответствующий лист.
- Если лист переполняется (число ключей > 2t - 1):
  - Лист делится на два узла.
  - Средний ключ поднимается в родительский узел.
- При необходимости процесс рекурсивно продолжается до корня.
- Если переполняется корень:
  - Создаётся новый корень.
  - Дерево увеличивается в высоту.

![Вставка](https://neerc.ifmo.ru/wiki/images/thumb/7/7a/B3insa.png/550px-B3insa.png)


### Удаление ключа

Удаление требует поддержания инвариантов дерева:
- Если ключ находится в листе — он удаляется напрямую.
- Если ключ находится во внутреннем узле:
  - Заменяется на максимальный ключ в левом поддереве или минимальный в правом.
  - Выполняется рекурсивное удаление.
- Если при переходе к потомку его размер меньше t:
  - Выполняется заимствование ключа у соседа или слияние с соседом.

![Удаление](https://neerc.ifmo.ru/wiki/images/thumb/5/5c/B3dell.PNG/550px-B3dell.PNG)

![Удаление](https://neerc.ifmo.ru/wiki/images/thumb/9/99/B3delin.png/550px-B3delin.png)
---

## Реализация структуры данных

### Класс `Node`

- Представляет узел дерева.
- Поля:
  - `data`: `[[key1, key2, ...], [[value1_1, value1_2, ...], [value2_1, value2_2, ...], ...]]`.
  - `children`: `[child1, child2, ...]`.
  - `leaf`: флаг, определяющий, является ли узел листом.
- Методы:
  - `get_keys()`, `get_values()`, `get_pair(index)`.
  - Операции вставки (`append_pair`, `insert_pair`) и удаления (`pop_pair`, `remove_value`).
  - Обрезка (`slice_data`) и замена (`replace_data`) данных.

### Класс `BTree`

- Представляет само дерево.
- Поля:
  - `root`: корень дерева.
  - `t`: минимальная степень дерева.
- Основные методы:
  - `search(key)`: поиск ключа.
  - `insert(key, value)`: вставка ключа.
  - `delete(key)`: удаление ключа.
  - `remove_value(value)`: удаление конкретного значения среди всех ключей.
  - `print_tree()`: вывод структуры дерева уровнями.


---

## Сводная таблица операций

| Операция | Среднее время | Худшее время |
| :------- | :------------ | :----------- |
| Поиск    | O(logₜ n)      | O(logₜ n)    |
| Вставка  | O(logₜ n)      | O(logₜ n)    |
| Удаление | O(logₜ n)      | O(logₜ n)    |

где `t` — степень дерева, `n` — количество ключей.

---

## Сравнение: B-дерево vs. Hash Map

| Категория                       | B-дерево                                                     | Хэш-мапа (Hash Map)                                          |
|---------------------------------|--------------------------------------------------------------|--------------------------------------------------------------|
| Поиск по точному значению       | O(log n) — поиск по дереву                                   | O(1) — мгновенный поиск по хешу ключа                        |
| Поиск по диапазону              | Поддерживается напрямую (обход дерева)                       | Невозможно без полного перебора                              |
| Поддержка сортировки            | Ключи хранятся отсортированными                              | Нет упорядоченности                                          |
| Сравнительные операторы         | Поддерживаются: `>`, `<`, `>=`, `<=`, `==`, `!=`             | Требуется перебор всех элементов                             |
| Итерация по ключам              | Упорядоченный обход                                          | Непредсказуемый порядок                                      |
| Реализация                      | Сложная: поддержка баланса, слияние узлов                    | Простая: хранение пар ключ-значение                          |          
| Потребление памяти              | Эффективное использование памяти                             | Выше из-за возможных коллизий и перераспределений            |
| Используется в                  | PostgreSQL, MySQL (InnoDB), MongoDB                          | Redis, MongoDB (hashed index), Memcached                     |
